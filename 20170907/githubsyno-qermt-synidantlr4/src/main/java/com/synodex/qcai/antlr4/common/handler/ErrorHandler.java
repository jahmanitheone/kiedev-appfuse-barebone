package com.synodex.qcai.antlr4.common.handler;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.Token;
import org.apache.log4j.Logger;

/**
 * Antlr4 base error listener.
 * 
 * This class processes the errors generated by the antlr4 rule.
 * 
 * @author pchauvet
 */
public class ErrorHandler extends BaseErrorListener {
	private final static Logger log = Logger.getLogger(ErrorHandler.class);
	private List<String> errors = new ArrayList<String>();

	@Override
	public void syntaxError(Recognizer<?, ?> recognizer,
			Object offendingSymbol, int line, int charPositionInLine,
			String msg, RecognitionException e) {
		List<String> stack = ((Parser) recognizer).getRuleInvocationStack();
		Collections.reverse(stack);

		String erromsg = "";
		// erromsg = "rule stack: " + stack;
		setError(erromsg);

		// erromsg = "\r\nline " + line + ":" + charPositionInLine + " at "
		// + offendingSymbol + ": " + msg;
		erromsg = "\r\nline " + line + ":" + charPositionInLine + " " + msg;

		erromsg += "\r\n"
				+ underlineError(recognizer, (Token) offendingSymbol, line,
						charPositionInLine);

		log.error("ppppp: erromsg: " + erromsg);

		setError(erromsg);
	}

	protected String underlineError(Recognizer recognizer,
			Token offendingToken, int line, int charPositionInLine) {
		CommonTokenStream tokens = (CommonTokenStream) recognizer
				.getInputStream();
		StringBuilder msg = new StringBuilder();

		String input = tokens.getTokenSource().getInputStream().toString();
		String[] lines = input.split("\r\n");
		String errorLine = lines[line - 1];
		msg.append(errorLine.trim() + "\r\n");

		int start = offendingToken.getStartIndex();
		int stop = offendingToken.getStopIndex();

		log.debug("charPositionInLine: " + charPositionInLine);
		log.debug("start: " + start);
		log.debug("stop: " + stop);

		if (start >= 0 && stop >= 0) {
			if (start < stop) {
				for (int i = 0; i < charPositionInLine; i++)
					msg.append(".");

				for (int i = start; i <= stop + 1; i++)
					msg.append("^");
			} else {
				for (int i = 0; i < charPositionInLine - 1; i++)
					msg.append(".");

				for (int i = start; i <= stop + 1; i++)
					msg.append("^");
			}
		}

		msg.append("\r\n");

		return msg.toString();
	}

	/**
	 * Get errors as a message dumped in a string
	 * 
	 * @return
	 */
	public String getErrorMessages() {
		StringBuilder bld = new StringBuilder();

		List<String> errors = getErrors();
		for (String err : errors) {
			bld.append(err);
		}

		return bld.toString();
	}

	public List<String> getErrors() {
		return errors;
	}

	public void setError(String error) {
		errors.add(error);
	}

	public boolean hasErrors() {
		return !errors.isEmpty();
	}

}
